"""Neural net model"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/models.resnet.ipynb.

# %% auto 0
__all__ = ['logger', 'ResBlock', 'ResNet']

# %% ../../nbs/models.resnet.ipynb 3
import torch.nn as nn
import torch.nn.functional as F
import torch
from torch_lr_finder import LRFinder

from omegaconf import OmegaConf
from hydra.utils import instantiate

from matplotlib import pyplot as plt

from .conv import ConvLayer
from ..utils import get_device, set_seed

from typing import List
import logging

# %% ../../nbs/models.resnet.ipynb 4
logger = logging.getLogger(__name__)
set_seed()

# %% ../../nbs/models.resnet.ipynb 6
class ResBlock(nn.Module):
    """ResNet basic block with optional downsampling.
    This block implements the basic building block of ResNet architecture,
    consisting of two convolutional layers with a residual connection.
    The block can optionally downsample the input using strided convolution
    and average pooling.

    Parameters
    ----------
    in_channels : int
        Number of input channels
    out_channels : int
        Number of output channels
    stride : int, optional
        Stride for the second convolution and pooling, by default 1
    kernel_size : int, optional
        Kernel size for the convolutions, by default 3
    
    Notes
    -----
    The block performs the following operations:
    1. First convolution with kernel_size and stride=1
    2. Second convolution with kernel_size and specified stride
    3. Identity/1x1 conv on residual path depending on channel dimensions
    4. Average pooling on residual path if stride > 1
    5. ReLU activation after element-wise addition
    The output dimensions are determined by the stride parameter:
    - If stride=1: output has same spatial dimensions as input
    - If stride=2: output spatial dimensions are halved
    """


    def __init__(
            self,
            in_channels: int, # Number of input channels
            out_channels: int, # Number of output channels
            stride: int = 1, # Stride for the second convolution and pooling
            kernel_size:int = 3 # Kernel size for the convolutions
            ):
        
        super().__init__()

        conv_ = nn.ModuleList()
        conv_.append(ConvLayer(in_channels, out_channels, stride=1, kernel_size=kernel_size))
        conv_.append(ConvLayer(out_channels, out_channels, stride=stride, activation=None))
        self.conv = nn.Sequential(*conv_)


        if in_channels == out_channels:
            self.id = nn.Identity()
        else:
            self.id = ConvLayer(in_channels, out_channels, stride=1, kernel_size=1, activation=None)

        if stride == 1:
            self.pool = nn.Identity()
        else:
            self.pool = nn.AvgPool2d(2, ceil_mode=True)
        self.act = nn.ReLU()
        
    def forward(self, x):
        return self.act(self.conv(x) + self.id(self.pool(x)))

# %% ../../nbs/models.resnet.ipynb 11
class ResNet(nn.Module):
    """A simple implementation of a ResNet-like neural network.

    Parameters
    ----------
    n_features : List[int], optional
        A list of integers representing the number of features (channels) at each layer. 
        Default is [1, 8, 16, 32, 64, 128, 256].
    num_classes : int, optional
        The number of output classes. Default is 10.
    """

    def __init__(
            self,
            n_features:List[int]=[1, 8, 16, 32, 64, 128, 256], # channel/feature expansion
            num_classes:int=10, # num_classes
        ):

        super().__init__()

        layers = nn.ModuleList()
        layers.append(ResBlock(n_features[0], n_features[1], stride=1))

        for i in range(1, len(n_features)-1):
            res = ResBlock(n_features[i], n_features[i+1], stride=2)
            layers.append(res)

        layers += [nn.Flatten(), nn.Linear(n_features[-1], num_classes, bias=False), nn.BatchNorm1d(num_classes)]


        self.nnet = nn.Sequential(*layers)

    def forward(self, x:torch.Tensor)->torch.Tensor:
        return self.nnet(x)

