"""Neural net modules"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/models.diffusion.ipynb.

# %% auto 0
__all__ = ['logger', 'DiffusorX']

# %% ../../nbs/models.diffusion.ipynb 3
import torch.nn as nn
import torch.nn.functional as F
import torch
from torchvision.transforms import transforms

import os
import logging
import warnings
from omegaconf import OmegaConf
from hydra.utils import instantiate
from tqdm.notebook import tqdm
from dataclasses import dataclass
from typing import List, Optional, Callable, Any
from functools import partial


from matplotlib import pyplot as plt
import numpy as np

from ..utils import get_device, set_seed, time_it
from ..image.datasets import ImageDataset, show_images, make_grid
from .core import lr_finder, train_one_cycle, Regressor

import diffusers
from diffusers import UNet2DModel, DDPMScheduler, DDPMPipeline, DDIMScheduler
from diffusers.utils import make_image_grid
from diffusers.optimization import get_cosine_schedule_with_warmup

# %% ../../nbs/models.diffusion.ipynb 4
set_seed(42)
logger = logging.getLogger(__name__)
warnings.filterwarnings("ignore", category=UserWarning, module="matplotlib.image")

# %% ../../nbs/models.diffusion.ipynb 32
class DiffusorX(Regressor):
    def __init__(
        self,
        nnet: diffusers.UNet2DModel,
        noise_scheduler: diffusers.DDPMScheduler,
        optimizer:Callable[...,torch.optim.Optimizer], # optimizer,
        scheduler: Optional[Callable[...,Any]]=None, # scheduler
    ):
        super().__init__(
            nnet=nnet,
            optimizer=optimizer,
            scheduler=scheduler
        )
        
        self.noise_scheduler = noise_scheduler
        self.nnet = nnet
        logger.info("DiffusionX: init")
    
    def forward(
        self,
        x:torch.Tensor, # noisy image
        t:torch.Tensor # time step
        )->torch.Tensor: # noise estimate
        return self.nnet(x, t).sample

    def _step(self, batch, batch_idx):
        # logger.log("step!")
        x, y = batch # x: clean image, y: label
        B, C, H, W = x.shape
        # linspace?
        # t = torch.linspace(0, self.noise_scheduler.config.num_train_timesteps -1, (B,)).long() # dim (B)
        t = torch.randint(0, self.noise_scheduler.config.num_train_timesteps, (B,)).to(self.device) # dim (B))
        noise =  torch.randn(x.shape).to(self.device) # B,C,H,W
        # self.noise_scheduler = self.noise_scheduler.to(self.device)
        noisy_img = self.noise_scheduler.add_noise(x, noise, t) # 
        noise_pred = self.forward(noisy_img, t)
        loss = self.criterion(noise_pred, noise)
        return loss, noise_pred, noise # loss, y_hat, y

