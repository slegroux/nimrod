"""Image datasets"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/image.datasets.ipynb.

# %% auto 0
__all__ = ['logger', 'ImagePlotMixin', 'ImageDataset', 'ImageDataModule']

# %% ../../nbs/image.datasets.ipynb 3
# torch
import torch
from torch import Tensor # type hint
import torch.utils.data as data
from torch.utils.data import ConcatDataset, DataLoader, Dataset, random_split
# torchvision
from torchvision.transforms import transforms
# lightning
from lightning import LightningDataModule
# hugging face
from datasets import load_dataset, load_dataset_builder
import datasets
# math
import pandas as pd
from matplotlib import pyplot as plt
import numpy as np
# python libs
import os
import logging
import warnings
from pprint import pprint
from plum import dispatch
# conigs
from omegaconf import OmegaConf
from hydra.utils import instantiate
# typing
from typing import Optional, Tuple, List, Callable, Union, Dict
# nimrod
from ..data.core import DataModule
from ..utils import set_seed

# %% ../../nbs/image.datasets.ipynb 4
set_seed(42)
logger = logging.getLogger(__name__)
# logger.setLevel(logging.DEBUG)
plt.set_loglevel('INFO')
warnings.filterwarnings("ignore", category=UserWarning, module="matplotlib")

# %% ../../nbs/image.datasets.ipynb 7
class ImagePlotMixin:
    " Mixin class for image datasets providing visualization of (image, label) samples"

    @staticmethod
    def plot(
        ds: Dataset,
        idx: int,
        int2label: Dict[int, str] | Callable = None
        ):
        X, label = ds[idx]
        C, H, W = X.shape
        if C == 1:
            # X (1, H, W)
            plt.imshow(X[0].numpy(), cmap='gray') 
        elif C == 3:
            # X (3, H, W)
            plt.imshow(X.numpy().transpose(1,2,0).reshape(H,W,C))
        # Convert label to string if possible
        try:
            # label_str = ds.hf_ds.features['label'].int2str(label)
            if isinstance(int2label, dict):
                label_str = int2label[label]
            elif isinstance(int2label, Callable):
                label_str = int2label(label)
            else:
                label_str = str(label)
        except AttributeError:  
            logger.warning("Unable to convert label to string")
        plt.title(f"Label: {label_str}")
        plt.show()

    @staticmethod
    def plot_grid(
        ds: Dataset,
        n_rows:int=3,
        n_cols:int=3,
        int2label: Dict[int, str] | Callable = None
        ):
        """
        Plot a grid of random images from the dataset
        
        Args:
            n_rows (int): Number of rows in the grid
            n_cols (int): Number of columns in the grid
        """
        fig, axs = plt.subplots(n_rows, n_cols, figsize=(10, 10))
        
        # Flatten axs if it's a 2D array
        if n_rows > 1 and n_cols > 1:
            axs = axs.flatten()
        
        for i in range(n_rows * n_cols):
            # Randomly select an index
            idx = torch.randint(0, len(ds), (1,)).item()
            
            # Get image and label
            img, label = ds[idx]
            C, H, W = img.shape
            
            # Handle different channel configurations
            if C == 1:  # Grayscale
                plot_img = img[0].numpy()
                cmap = 'gray'
            elif C == 3:  # RGB
                plot_img = img.numpy().transpose(1, 2, 0).reshape(H,W,C)
                cmap = None
            
            # Plot the image
            axs[i].imshow(plot_img, cmap=cmap)
            
            # Convert label to string if possible
            try:
                # label_str = ds.hf_ds.features['label'].int2str(label)
                if isinstance(int2label, dict):
                    label_str = int2label[label]
                elif isinstance(int2label, Callable):
                    label_str = int2label(label)
                else:
                    label_str = str(label)
            except AttributeError:
                logger.warning("Unable to convert label to string")
            
            axs[i].set_title(f"Label: {label_str}")
            axs[i].axis('off')
    
        plt.tight_layout()
        plt.show()

        

# %% ../../nbs/image.datasets.ipynb 10
class ImageDataset(ImagePlotMixin, Dataset):
    "Image dataset"

    def __init__(
        self,
        name:str = "mnist",
        data_dir:Optional[str]='../data/image', # path where data is saved if None default to hugging face cache
        train = True, # train or test dataset
        transforms:Optional[transforms.Compose]=transforms.Compose([
                transforms.ToTensor(),
                transforms.Normalize((0.1307,), (0.3081,))]),
        streaming:bool = False # TODO: support and test streaming datasest
    ):

        logger.info(f"{name} Dataset: init")
        if data_dir is not None:
            os.makedirs(data_dir, exist_ok=True)
        super().__init__()

        split = 'train' if train else 'test'

        self.hf_ds = load_dataset(
            name,
            split=split,
            cache_dir=data_dir,
            download_mode='reuse_dataset_if_exists',
            streaming=streaming
        )
        if name == 'cifar10':
            self.images = self.hf_ds['img']
        else:
            self.images = self.hf_ds['image']
        self.labels = self.hf_ds['label']
        self.transform = transforms

    @property
    def num_classes(self):
        return self.hf_ds.features['label'].num_classes
    
    @property
    def int2str(self):
        return self.hf_ds.features['label'].int2str

    def __len__(self) -> int: # length of dataset
        return len(self.images)
    
    def __getitem__(
        self,
        idx:int # index into the dataset
    ) -> tuple[torch.FloatTensor, int]: # Y image data, x digit number
      
        image = np.array(self.images[idx])
        label = self.labels[idx]
        if self.transform:
            image = self.transform(image)
        return image, label
    
    def train_dev_split(
        self,
        ratio:float, # percentage of train/dev split,
    ) -> tuple[Dataset, Dataset]: # train and set mnnist datasets

        train_set_size = int(len(self.images) * ratio)
        valid_set_size = len(self.images) - train_set_size
        ds = list(zip(self.images, self.labels))
        # split the train set into two randomly sample
        train_set, valid_set = data.random_split(ds, [train_set_size, valid_set_size])
        return train_set, valid_set

    def show(
        self,
        idx:int # index into the dataset
        ):
        self.plot(self, idx, self.hf_ds.features['label'].int2str)

    def show_grid(
        self,
        n_rows:int=3, # Number of rows in the grid
        n_cols:int=3 # Number of columns in the grid
        ):
        self.plot_grid(self, n_rows, n_cols, self.hf_ds.features['label'].int2str)
    

# %% ../../nbs/image.datasets.ipynb 20
class ImageDataModule(ImagePlotMixin, DataModule, LightningDataModule):
    def __init__(
        self,
        name: str = "mnist",
        data_dir: Optional[str] = "~/Data/", # path to source data dir
        transforms: Union[transforms.Compose, Callable, None] = transforms.Compose([
            transforms.ToTensor(),
            transforms.Normalize((0.1307,), (0.3081,))
        ]),
        train_val_split:List[float] = [0.8, 0.2], # train val test %
        batch_size: int = 64, # size of compute batch
        num_workers: int = 0, # num_workers equal 0 means that it’s the main process that will do the data loading when needed, num_workers equal 1 is the same as any n, but you’ll only have a single worker, so it might be slow
        pin_memory: bool = False, # If you load your samples in the Dataset on CPU and would like to push it during training to the GPU, you can speed up the host to device transfer by enabling pin_memory. This lets your DataLoader allocate the samples in page-locked memory, which speeds-up the transfer
        persistent_workers: bool = False
        ):

        logger.info(f"Init ImageDataModule for {name}")
        super().__init__(train_val_split, batch_size, num_workers, pin_memory, persistent_workers)
        self.save_hyperparameters()
        self.train_ds, self.test_ds, self.val_ds = None, None, None
        self.int2str = None
        self._num_classes = None

    @property
    def num_classes(self) -> int: # num of classes in dataset
        return self._num_classes

    def prepare_data(self) -> None:
        """Download data if needed 
        """
        # train set
        self.train_ds = ImageDataset(
            name = self.hparams.name,
            data_dir = self.hparams.data_dir,
            train=True,
        )
        # get num classes before setup method converst ImageDataset to Subset
        self._num_classes = self.train_ds.num_classes
        # save class names before splitting test/valid and losing property
        self.int2str = self.train_ds.int2str
        # test set
        self.test_ds = ImageDataset(
            name = self.hparams.name,
            data_dir = self.hparams.data_dir,
            train=False
        )

    def setup(self, stage: Optional[str] = None) -> None:
        # called on every GPU when distrib
        # stage: {fit,validate,test,predict}\n",
        # concat train & test mnist dataset and randomly generate train, eval, test sets
        if not self.train_ds:
            self.train_ds = ImageDataset(self.hparams.name, self.hparams.data_dir, train=True, transforms=self.transforms)
        if not self.test_ds:
            self.test_ds = ImageDataset(self.hparams.name, self.hparams.data_dir, train=False, transforms=self.transforms)
        if not self.val_ds:
            # dataset = ConcatDataset(datasets=[trainset, testset])
            logger.info(f"split train into train/val {self.hparams.train_val_split}")
            lengths = [int(split * len(self.train_ds)) for split in self.hparams.train_val_split]
            self.train_ds, self.val_ds = random_split(dataset=self.train_ds, lengths=lengths)
            logger.info(f"train: {len(self.train_ds)} val: {len(self.val_ds)}, test: {len(self.test_ds)}")
    
    def show(self, idx):
      self.plot(self.train_ds, idx, self.int2str)
    
    def show_grid(self, nrow, ncols):
        self.plot_grid(self.train_ds, nrow, ncols, self.int2str)
        
